[[{"l":"Differential","p":["Build, Deploy and Refactor fault-tolerant back-end apps without the ceremony.","Differential is in the technical preview stage, and is open-source. We are working hard to make our offering generally available. Sign up for the waitlist here.","Differential is an open-source application code aware service mesh (control-plane) and a set of adapters (client libraries) which connects your services together with first-class support for Typescript.‍ Differential is a framework that builds on the concepts developers are already familiar with.","Services are collections of plain old javascript functions which can be deployed in almost any compute. Services ship their own type-safe Typescript clients.","The control plane takes care of routing data between the functions, and recovering from transient failures, transparently."]},{"l":"Open Source and Self-Hostable","p":["Differential is released under the Apache 2.0 license, and can be self-hosted. This means you can run your own control-plane, and have full control over your data and infrastructure. Optionally, you can use Differential Cloud, which is a fully managed offering that we are working hard to make generally available. Sign up for the waitlist here."]},{"l":"Quick Start","p":["Follow the Quick Start guide to get up and running with Differential in under 2 minutes."]},{"i":"see-also","l":"See Also:","p":["Get up and running with Differential in under 2 minutes","Thinking in Differential"]}],[{"l":"Thinking in Differential","p":["Differential is a little bit different (pun intended) from the way it looks at separation of services from the way you might be used to."]},{"l":"The Differential Way","p":["1. Services are a collection of functions.","2. There are no restrictions on what these functions can do. They are just functions.","3. Services can be co-located on the same codebase, or spread out across multiple repositories. Differential doesn't make any assumptions on the file structure.","4. Starting a service is as simple as calling service.start(). Stopping is done via a service.stop().","You can have 1:1 services to processes, or you can have multiple services running in the same process. It's up to you. You can also start and stop services dynamically at runtime.","5. Once a service is started, it registers itself with the control-plane, and starts asking for \"work\".","The open-source control-plane is a central service that keeps track of all the services that are running, and their health. It acts as a service registry, and a service mesh. Your services don't talk to each other directly. Instead, they talk to the control-plane, which routes the function calls to the correct service.","6. You can call any function in any service from any other service.","You don't need to know where the service is running, or how to connect to it. You just need to know the name of the service and the name of the function. Function calls get routed to the correct service by the control-plane.","7. Your function calls are type-safe","You can't call a function that doesn't exist, or pass the wrong arguments as long as you set up the client library object with a reference to the service.","8. Calling a function has the same ergonomics as calling a local function.","You can just call the function and it will return the result, even if it results in an Error. SDK and the control-plane routes the function call to the correct service, and does the proper serialization and deserialization of arguments and return values."]},{"i":"why","l":"Why?","p":["1. Overhead of microservices architecture can have sensible defaults.","2. Writing duplicative service interfaces/contracts can be avoided.","3. Anything a service has ever done can and should be represented by a single function definition.","4. Internal services should remain internal.","5. The disadvantages of a centralized control-plane are outweighed by the advantages.","A service bus that is aware of the application code can provide a better developer experience by offering type-safety and a single place to find all the services and their functions.","A service should stay internal until it's ready or necessary to be exposed externally. Starting a service on a port should be a conscious decision, not the default.","A type-safe language that can infer types should be able to infer the contract of a service from the service's implementation.","But the resulting ovehread of managing all the service-to-service communication concerns, tooling, and infrastructure can be overwhelming.","Communication via queues and pub/sub is a possible alternative, but it introduces complexities such as keeping track of channels:message types, message serialization, message delivery guarantees, and additional infrastructure configuration that lives outside of the code that does the work.","Differential is an opinionated framework. It makes some tradeoffs to make it easier to build services. They might not be the right tradeoffs for you, but we think they are the right tradeoffs for most people.","Every RPC framework introduces more complexity to deal with the impedance mismatch between the language and the wire format.","GraphQL has queries and mutations, but you need complex tooling to generate the types.","In REST, it's hard to model operations that doStuff().","Instead of n services talking to n services, a service bus allows streamlining the communication to a single service and fan-out from there.","Microservices architecture can really shine when you want to scale a specific part of your system, prevent cascading failures, move your workloads to on-demand compute etc.","Modern RPC frameworks like gRPC and tRPC solve some of the problems, but they make different tradeoffs for stronger contracts and language/runtime interoperability.","Moreover, microservices that can minimize the cold start time, and can be started and stopped dynamically would increase adoption of the architecture.","Not having a compile step to generate contracts (e.g., protobufs) or a duplicative interface (tRPC) definition allows you to move faster.","Such an architecture allows for a single place to implement cross-cutting concerns such as authentication, authorization, rate limiting, and observability.","There exists a set of sensible defaults that can be applied to most services, and common concerns that can be abstracted away."]}],[{"l":"Writing your first app with Differential","p":["In this guide, we'll walk you through creating a simple service with Differential. We will:","Create your first Differential cluster","Create a simple service that returns a greeting","Call the service from a client","See the cluster activity from the Differential Dashboard"]},{"l":"1. Install the Differential CLI","p":["To get started with Differential, you'll need to install the Differential CLI. You can do this by running the following command:"]},{"l":"2. Authenticate with Differential","p":["To authenticate with Differential, run the following command:"]},{"l":"3. Create a directory for your service"},{"l":"4. Initialize your project","p":["The following command will create a new project in the current directory. And install the necessary dependencies."]},{"l":"5. Create a Differential cluster","p":["This will give you a API Secret. Copy this to the clipboard so we can use it in the next step."]},{"i":"6-initialize-your-differential-client","l":"6. Initialize your Differential client.","p":["Create a new file called src/d.ts and add the following code:","Make sure to replace YOUR_API_SECRET with the API Secret you copied in the previous step."]},{"l":"7. Create your first service","p":["Now we'll create a simple hello world service in the src/service.ts file.","You can now run your service with the following command:"]},{"l":"8. Call your service","p":["Now that your service is running, you can call it from anywhere, as long as it can connect with the correct Differential cluster.","Let's create a simple script that calls the hello function on the hello service.","Create a new file called src/call-hello.ts and add the following code:","You can run this script with the following command:"]},{"l":"9. Check out the cluter activity","p":["You've just created your first Differential service! To see the internal of your cluster, you can run the following command:","You can now build more complex services by adding more functions to your service and calling them from your client."]}],[{"l":"AI-Powered Retry Logic for Promise","p":["Status: Technical Preview","This feature is at the Technical Preview stage. Due to the nature of probabilistic outcomes, this feature may result in non-deterministic behaviour. It's opt-in and switched off by default.","As with all Differential AI features, you might determine that your risk tolerance is lower than what this feature requires. In that case, you do not have to do anything and the feature will not be exposed to your users.","Differential can predict transient errors and retry the operations without the developer having to write custom code."]},{"l":"How it works","p":["The control-plane has all the required context on a particular failure, when it happens. It knows the function, some metadata about the source, payload, and the error message. It can use this information to predict if the error is transient or not.","If it's predicted to be transient, Differential will retry the operation again without any client intervention. This is especially useful for database deadlocks, network errors, and other transient errors."]},{"l":"Errors in the worker","p":["For example, let's consider this that occurs due to a database deadlock:","Calling this function will result in a deadlock error:"]},{"l":"Automatically recovering from transient errors","p":["Predictive retries can be enabled by setting the predictiveRetriesOnRejection key in the call configuration object. This will retry the function call if the worker rejects the job, based on the output of our internal AI workflow.","By enabling predictive retries, Differential will retry the operation again transparently once it predicts the error to be transient:"]},{"l":"How to help Differential AI to predict transient errors","p":["Clear, human readable error messages would help Differential to predict transient errors more accurately. Differential uses the error message to predict if the error is transient or not. If the error message is not clear, Differential may not be able to predict the error accurately.","Pass down the error context without overwriting it.","Differential AI can handle well known error codes, such as ER_LOCK_DEADLOCK in MySQL, ECONNRESET in network errors, or 429 s in HTTP requests. If you have a well known error code, you can pass it down in the error context to Differential AI to help it predict the error accurately."]},{"l":"Behaviour","p":["It's worth noting that Differential doesn't retry the operation indefinitely. It has a retry limit for any function call that results in a transient error (default 3 times). If the function fails more than the retry limit, Differential will return the error to the client, so that client can handle it."]}],[{"l":"Building Shared Client Libraries for Services","p":["Status: Private Beta","Differential supports publishing a client library for your cluster which can be included in a separate project using npm. Client libraries are distributed privately via a node package registry managed by Differential.","The Differential CLI is used to manage client libraries, you can publish a new client library with the client publish command.","Differential uses semantic versioning, as part of publishing the client library you will be asked to describe the change increment ( patch, minor, majod).","Once published, the client can be installed in other projects as you would any other node package.","The differential auth login CLI command configures the host's ~/.npmrc configuration to authenticate with the Differential package registry. If you need to install the package from another host, run npm auth login.","This will provide a type safe client which can be used to call any service in the cluster.","Shared client libraries are currently in private beta and will be available soon. To gain early access, please sign up for the waitlist here."]}],[{"l":"How to cache results of function calls","p":["Since all function calls within Differential are durable, the control-plane can cache the results of function calls. When subsequent function calls are made for the same operation, you can opt to return the cached result instead of executing the operation again.","This will save you compute and network resources, and also reduce the latency of the function call."]},{"l":"Configuring the Cache Key and TTL","p":["You can configure the key and time-to-live (TTL) for the cache (in seconds) whenever you call a function.","In the above example, the result of the function call will be cached with the key myCacheKey for 60 seconds. If the same function is called again within 60 seconds with the same key, the cached result will be returned instead of executing the function again."]},{"l":"Multiple Cache Configurations for the same function","p":["You can configure multiple cache configurations for the same function call at different call sites. The configuration the function call honors is the only one that is configured in the function call config."]},{"l":"Cache Invalidation","p":["Since the cache key and the TTL are configured in the call to the function, to invalidate the cache, you can simply call the function without the cache configuration."]}],[{"l":"How to deduplicate function calls","p":["Consider a scenario where two or more function calls are issued for the same operation. Your code may be racing to complete the operation multiple times, or it may be the network which is repeatedly timing out and causing the same operation to be retried. In such cases, you may want to deduplicate the function calls to ensure that the operation is only executed once."]},{"l":"Execution ID","p":["Execution ID is a cluster-wide unique identifier that is generated and set for each function call.","Usually, the control-plane takes care of generating and setting the execution ID. However, you can also set the execution ID manually to deduplicate function calls."]},{"i":"what-happens-if-you-call-a-function-with-the-same-execution-id","l":"What happens if you call a function with the same Execution ID?","p":["When two or more function calls happen with the same Execution ID, the subsequent function calls will get the same result as the original function call.","If the first function call is still in progress, the subsequent function calls will wait for the original function call to complete and return the same result.","If the first function call has already completed, the subsequent function calls will return the same result as the original function call."]},{"i":"how-to-deduplicate-function-calls-1","l":"How to deduplicate function calls","p":["De-duplicating the function call can be done by setting the Execution ID for the function call. Here is an example of how you can set the Execution ID for a function call:"]}],[{"l":"How to end-to-end encrypt function arguments and return values","p":["You might wish to encrypt all function arguments and return values, so that the control plane cannot see them. This is possible with Differential, but it requires you to configure your own encryption keys.","These encryption keys are used to encrypt and decrypt the function arguments and return values. The control plane does not have access to these keys.","The Typescript example below shows how to configure your own encryption keys.","It accepts an array of encryption keys. This is useful if you want to rotate your encryption keys. Differential will try to decrypt the function arguments and return values with each encryption key until it finds one that works.","Since this essentially makes function arguments opaque to the control plane, it is important to note that Differential will not be able to provide any of its usual features for these encrypted function arguments, such as predictive retries or predictive alerting.","Caching is still supported, as it is based on the function arguments and return values as supplied by the client."]}],[{"l":"How to ensure idempotency in your functions","p":["Idempotency is a property of an operation that means the operation can be applied multiple times without changing the result beyond the initial application. In other words, making the same request multiple times has the same effect as making the request once.","In the context of Differential, you can easily achive this by the combination of:","Retrying the function call if it gets rejected, which would allow you ensure at-least-once execution.","Checking a unique identifier in the request to ensure that the operation is not applied multiple times.","The following is an example of how you can implement idempotency:"]},{"l":"Guarding against duplicate requests due to stalled machine retries","p":["If a machine processing a request stalls, Differential will retry the request on another machine. This can lead to the same request being processed multiple times. To guard against this, you must use a unique identifier in the execution chain and check if the operation has already been applied explicitly."]}],[{"l":"Predictive Alerting","p":["Status: In Development","Differential can predict if a function is failing due to an unrecoverable error that requires a code change, and alert you with reproduction steps.","The control-plane has all the required context on a particular failure, when it happens. It knows the function, some metadata about the source, payload, and the error message. It can use this information to predict if the error is unrecoverable or not.","If it's predicted to be unrecoverable, Differential will alert you prompting to make the necessary code change. This is especially useful for errors that are hard to reproduce, and require a code change to fix.","For example, let's consider this that occurs due to a data inconsistency:","In this case, Differential can predict that the error is unrecoverable, and prompt you to make a code change. It will provide you with the exact payload that caused the error, and the reproduction steps to reproduce the error locally."]}],[{"l":"Retrying function calls on infrastructure failures","p":["Sometimes the functions can stall due to a machine crashing, network issues, or other infrastructure failures. In these cases, you can instruct Differential to retry the function call without writing any custom error recovery logic."]},{"l":"Retry Configuration","p":["You can configure the number of times a function call should be retried in case of a stall. By default, Differential retries the function call once. You can customize this behavior by setting the retryCountOnStall key in the configuration object.","Imagine you have a function that takes a long time to execute:","You can configure the number of times the function should be retried in case of a stall:"]},{"l":"Default Behavior","p":["The default behavior is to retry the function call once, after the function times out. The default timeout is 5 minutes.","For example, the following function will be retried once after 5 minutes."]},{"l":"Retries vs. Failures","p":["Note that this retry mechanism is different from the retries that are done when a function call is rejected. When a function call is explicitly rejected becasue of a throw, reject or an unhandled exception, it is up to the client to retry the function call."]}],[{"l":"Call Configuration and Customizing Function Calls","p":["Any function call in Differential can be customized with additional metadata. The configuration is passed as the second argument to the function call. This metadata can be used to control the behavior of the function call, such as setting a cache key, specifying a timeout, etc.","At the runtime, the configuration options are interpreted by the client libraries and the control-plane to induce the desired behavior."]},{"l":"Configuration Options","p":["These are the configuration options that can be passed to a function call under the $d key:"]},{"l":"Caching","p":["Caching can be achieved by setting the cache key in the configuration object. The key is a unique identifier for the cache entry, and ttlSeconds is the time-to-live for the cache entry in seconds.","This will look up any other function calls that would have been resolved with the same cache key within the ttlSeconds time frame and return the latest one."]},{"l":"Retries","p":["A function call might stall when the function can't complete within the alotted timeout interval or when a worker stalls. Differential automatically retries this call one more time by default. This can be customized by setting the retryCountOnStall key in the configuration object."]},{"l":"Predictive Retries","p":["Predictive retries can be enabled by setting the predictiveRetriesOnRejection key in the configuration object. This will retry the function call if the worker rejects the job, based on the output of our internal AI workflow. Read more about Predictive Retries. Due to the nature of probabilistic outcomes, this feature is opt-in and switched off by default."]},{"l":"Timeout","p":["The timeout for a function call can be set by specifying the timeoutSeconds key in the configuration object. This will cause the function call to fail if it doesn't complete within the specified time via a DifferentialError.TIMEOUT error.","Note: the timeout refers to the time taken by the function to complete on the worker. Therefore, the actual time taken as observed by the client might be higher due to network latency, time taken to distribute the job, and the time taken to obtain and process the response."]},{"l":"Execution ID","p":["The executionId key can be set in the configuration object to specify the execution ID for the function call. This can be used to track the execution of the function call across the control-plane and the workers. But perhaps the most useful feature is using the execution ID to prevent duplicate function calls, as the same execution ID for the same function in the same cluster will be resolved to the same result, if the result has been resolved before."]}],[{"l":"Argument and return values","p":["One benefit of using Differential is that is abstracts away many of the complexities of network and data serialization. However, as with any abstraction - it is optimised for the most common use-cases and leaks some of the underlying complexity in the form of limitations.","Differential serializes function arguments and return values with the same algorithm, so the limitations are the same for both."]},{"l":"Serializability","p":["Differential uses Message Pack for serializing function arguments and return values. It serializes the actual values, not the references to the values. Therefore, if your function arguments or return values contain references to objects, they will not be serialized correctly."]},{"l":"Data Type Compatibility","p":["This is a table of data types and their compatibility with Differential as validated by the test suite:","Data Type","Supported","undefined","✅","null","boolean","number","string","bigint","object","Array","Buffer","Date"]},{"l":"Advanced Data Types","p":["It is theoretically possible to pass more complex data types such as Map, Set, TypedArray, Error, RegExp, Function, Promise, Symbol, WeakMap, WeakSet, ArrayBuffer, SharedArrayBuffer, DataView, Int8Array, Uint8Array etc, as long as they are not nested and do not contain references to objects. However, they go through a serialization process that requires extra work to be properly deserialized on the other side.","For this purpose, they are left out of the initial offering."]},{"l":"Safety","p":["Differential adds a layer of safety by validating the data types of the function arguments and return values before serializing them. If the data types are not supported, Differential will throw an error DifferentialError.INVALID_DATA_TYPE. The peformance overhead of this validation is negligible. However, you can disable this behaviour by setting the validate option to false."]}],[{"l":"On-demand Compute","p":["Status: In Development","On-demand compute is Differential's managed compute offering that runs your Differential services on-demand in a serverless setting.","Since the control-plane has the knowledge of how many function calls are being made and how frequently, it can use this information to spin up the service on-demand and scale it down when it's not being used.","Because a single service session can execute multiple function calls, you don't have to worry about the cold start time of the function. The service will be kept warm for a certain period of time after the last function call.","On-demand compute is currently in development and will be available soon. To gain early access, please sign up for the waitlist here."]}],[{"l":"How functions fail","p":["Functions in Differential can \"fail\" in 2 main ways."]},{"l":"1. Promise rejection","p":["A function can fail via a promise rejection due to an explicity throw statement in the function code or due to an unhandled exception.","Differential does not automatically retry failed function calls - i.e., if a function call fails, it fails. It is up to the client to decide if it wants to retry the function call. This is the scenarios denoted by 1 and 2 above. The exception to this is predictive retries, which is an opt-in feature to retry function calls based on the error metadata."]},{"l":"2. Stalling","p":["A function can stall if it does not complete within the alotted time. This usually happens if:","Function fails to complete within the alotted timeoutSeconds time.","Worker stalls due to a machine crash or network problems. (See Recovering from machine failures for more information)","Differential does automatically retry function calls that stall. This can be customized by setting the retryCountOnStall key in the call configuration object."]}],[{"l":"How to handle failures","p":["Differential failure modes and error handling is not too dissimilar from the traditional failure modes and error handling in a service-oriented architecture."]},{"l":"A function call results in a rejection","p":["When a promise gets rejected from a remote function, Differential will serialize the error and send it back to the caller. The caller can then handle the error as needed.","Differential does not do any retries or error handling on behalf of the caller in this case. It is up to the caller to decide how to handle the error.","However, Differential does serialize the error and send it back to the caller, which allows the caller to handle the error as needed.","For example, given this service function:","The caller can handle the error like this:"]},{"l":"Stack trace","p":["Differential does preserve the stack trace that is generated when the error is thrown, in the remote function."]},{"l":"Error prototype","p":["Differential does preserve the prototype of all the native JavaScript errors as defined in the Well-Known Intrinsic Objects. This means that the caller can check the error type using the instanceof operator for these errors.","However, custom errors are not preserved across the boundary. This means that the caller cannot check the error type using the instanceof operator for custom errors. However, the caller can still check the class properties of the error to determine the error type - such as the name and message properties."]},{"l":"A function call results in a timeout","p":["When a function call results in a timeout, Differential will reject the promise with a DifferentialError, with a message of DifferentialError.REMOTE_EXECUTION_ERROR. The caller can then handle the error as needed."]},{"l":"A function call results in continued machine failure","p":["Differential can detect when a machine has stopped responding and will automatically failover to another machine. This also means that the functions that were running on the failed machine will be marked as stalled, so that they can be re-executed on another machine.","By default, a cluster will auto-retry a stalled function up to 3 times. If the function still fails after 3 retries, the function will be marked as failed and the caller will receive a DifferentialError with a message of DifferentialError.REMOTE_EXECUTION_ERROR.","Differential will prevent retrying the function indefinitely, to prevent a machine from continuously failing."]},{"l":"Network gets interrupted during a function call","p":["When the network gets interrupted during a function call, Differential will try to re-establish the connection to the control-plane.","Once the connection is re-established, the caller will continue to poll the control-plane for the results of the function. If the function has already completed, the caller will receive the results as expected.","In case of repeated failures, the number of cycles that Differential will try to re-establish the connection is configured via ResultsPoller.MAX_ERROR_CYCLES in the client. By default, this is set to 5, spaced out over 250 seconds. If the connection is not re-established after the configured number of cycles, the function will be marked as failed and the caller will receive a DifferentialError with a message of DifferentialError.TOO_MANY_NETWORK_ERRORS."]}],[{"l":"Recovering from machine failures","p":["In a cloud environment, machines can fail at any time. Differential transparently handles machine failures by periodically sending heartbeats to the control-plane, quickly catching and retrying failed operations on a healthy worker. This means that you don't have to worry about your service being unavailable due to a machine failure.","If a machine fails to send any heartbeats within an interval (default 90 seconds):","It is marked as unhealthy, and Differential will not send any new requests to it.","The functions in progress are marked as failed, and Differential will retry them on a healthy worker.","If the machine comes back online, Differential will mark it as healthy, and start sending new requests to it. However, it will disregard any results from the machine for the functions that were marked as failed.","However, it's possible that the particular workload that you're executing on the machine is what makes it crash. To account for this, there's a retry limit for any function call that results in a machine stall (default 1 time). If the function fails more than the retry limit, Differential will mark the function as permanently failed."]}],[{"l":"Concepts"},{"l":"Service","p":["A collection of functions that can be called by a consumer using the differential client. Defined using the SDK."]},{"l":"Host","p":["A computer that you operate and own, that runs your services."]},{"l":"Cluster","p":["A group services that are running on a host. An API key is required to join a cluster."]},{"l":"Control Plane","p":["A central service that keeps track of all the services that are running, and their health. It acts as a service registry, and a service bus."]}],[{"l":"Architecture","p":["Differential is currently in technical preview. We've seen promising early results, but our architecture is still evolving. We welcome your thoughts on our design choices. Join the discussion on our GitHub.","Differential’s architecture is intentionally straightforward. We adhere to the principle that simplicity leads to easier scalability, self-hosting, and iterative improvements. Our focus is on refining simplicity to achieve the most effective abstractions."]},{"l":"Key Components","p":["Control Plane","SDK"]},{"l":"Control Plane","p":["The Control Plane functions as the nerve center, handling job management and API interactions. Each function call translates into a job, identified by its name and arguments. The Control Plane dynamically assigns jobs to clients, ensuring a single job isn't processed by multiple clients by atomically updating its state to \"Running\".","To prevent job stalling, the Control Plane monitors job durations, flagging any that exceed predefined limits as failed. These can be retried according to customizable policies. We use a relational database (compatible with Postgres, CockroachDB, etc.) for storing all job states, facilitating self-hosting."]},{"l":"SDK"},{"l":"Service-side","p":["On initializing a service, the SDK registers with the Control Plane and begins polling for jobs. It maintains an in-memory function registry and a task queue. This task queue, whose concurrency level is adjustable, determines parallel function execution capacity.","For each job, the SDK identifies the corresponding function and executes it with the provided arguments. Results are then relayed back to the Control Plane."]},{"l":"Client-side","p":["The client-side of Differential involves invoking functions through a type-safe client established via the SDK. Function calls are serialized and sent to the Control Plane. The client then long-polls for the result, which, upon receipt, is deserialized for use.","In all operations, we use msgpack for its efficiency in serialization over formats like JSON."]},{"l":"Considered Tradeoffs","p":["Long Polling: We chose long polling over persistent connections like websockets for easier self-hosting and scalability of the Control Plane. This decision, while impacting performance, is under continuous evaluation.","Database Selection: Our choice of Postgres for job state storage offers rapid iteration and ease in self-hosting. It strikes a balance between performance and flexibility.","Serialization with Msgpack: Msgpack offers a compact binary format, favoring speed over the compression level achieved by schema-aware binary formats. This decision eliminates the need for intermediate language schemas for developers to maintain."]},{"l":"Future Enhancements and Community Engagement","p":["Differential is a collaborative, evolving project. We actively integrate community feedback into our development process. Future enhancements will focus on improving performance, scalability, and user experience based on real-world applications and user suggestions.","If you're planning to use Differential, we'd love to hear from you. Please reach out to us at hello@differential.dev or join the discussion on our GitHub."]}],[{"l":"Comparisons"},{"i":"comparisons-with-http--rest-apis","l":"Comparisons with HTTP / REST APIs"},{"l":"Working with Data","p":["Unlike REST APIs, with Differential, you don't need to cocern yourself with the HTTP status codes, serialization, or deserialization. Differential works with native data types, and provide type-safe interfaces for you to work with.","This prevents the developer from having to deal with the conversion overhead between programming constructs and HTTP constructs.","With differential, the equivalent code here:","becomes:"]},{"l":"Working with Multiple Services","p":["In a service-oriented architecture, you may have multiple services that you need to communicate with. These will be exposed as different REST APIs, and your clients will communicate with them in a m:m fashion.","With Differential, all your services and clients connect to a single cluster. Clients can access any service that connects to the cluster. How the connections are mapped out, can be traced via the source code without an additional layer of network that gets in the way.","Differential becomes your service gateway and an elegant service discovery mechanism."]},{"l":"Exposure of Internal Functions","p":["A traditional REST service will require you to implement authentication, so your clients have a trusted relationship with your server. This is usually done via a token-based authentication scheme, and middleware that checks for the token on every request. This is especially true if you can't trust the network that your clients are connecting from, such as outside of your VPC.","With Differential, your internal services are only exposed to the control-plane via a secure connection. This means that you don't need to implement authentication for your internal services, as they are not exposed to the outside world. Differential clients can only access the functions that you explicitly expose to them."]},{"l":"Type Safety","p":["Differential provides type-safe interfaces for your clients to interact with your services, without a compile step. This also means that you don't have to worry about intermediate representations like OpenAPI, and the overhead of maintaining them."]},{"l":"Language Agnosticism","p":["Differential is not language agnostic. If you need to connect two services written in different languages, you will need to implement a shim layer in Typescript, and connect them to the same cluster. Depending on your use case, this may be additional complexity that you don't need.","This is in stark contrast to something like a REST service that can publish a intermediary representation of its API, such as OpenAPI, and allow clients to generate code from it. This is a tradeoff that we have made, as we believe that the benefits of type safety outweigh the benefits of language agnosticism."]},{"i":"comparisons-with-grpc--protocol-buffers","l":"Comparisons with gRPC / Protocol Buffers"},{"i":"working-with-data-1","l":"Working with Data","p":["gRPC uses Protocol Buffers as its serialization format. This means that you need to define your data structures in a separate file, and compile them into your language of choice. This is an additional step that you need to perform, and build tooling towards.","Every change that is made to the data structures will require a recompilation of the data structures, and a redeployment of the service.","Differential uses native programming constructs, and does not require you to have a comparative .proto file or a complilation step. Compatibility of contracts is enforced by the type system. However, you do lose out on some of the gurantees that Protocol Buffers provides, such as backwards compatibility.","However, we do plan to support additional developer tooling that will optionally verify and protect against breaking changes in contracts."]},{"l":"Serialization","p":["Protocol Buffers uses its knowledge about the data structure to optimize the serialization, deserialization, and the message size over the wire. Differential does not have this knowledge, and uses msgpack (a binary serialization format) to serialize and deserialize data. This means that the message size over the wire will be typically larger than gRPC, but smaller than JSON."]},{"l":"Other notes","p":["The same notes that apply to REST APIs also apply to gRPC APIs for Working with Multiple Services, Exposure of Internal Functions, Type Safety, and Language Agnosticism."]}],[{"l":"Limitations"},{"l":"Programming language","p":["Differential only supports TypeScript until it gets to a stable release. We do plan to support other languages in the future, however we are intensely focused on creating the right abstractions for a single language first.","There's nothing preventing your from using Differential with JavaScript, however you will lose out on the type safety that Differential provides for your clients."]}],[{"l":"Monolith to Microservices and Back","p":["A key value proposition of Differential is that it makes it easy to break up your monolith into services. This is a big deal, because breaking up a monolith is traditionally a very high overhead process. Differential makes it easy to break up your monolith into services, and to change the boundaries of your services as your business requirements change.","It also makes it easy to hit \"Abort\" and go back to a monolith if you need to."]},{"l":"The Problem","p":["You have a well-architected monolith. You've determined that it's time to break it up into 2 or more services. But the overhead of going for a service-oriented/microservices architecture is traditionally very high. You have to:","Figure out which functionality to break out into a service","Split up the code","Decide on a service communication protocol (HTTP, gRPC, tRPC, etc)","Copy paste boilerplate code for each service and/or write libraries to abstract away the boilerplate","Set up obervability / health checks / etc for each service","Write/move the business logic for each service","Write the service interfaces for each service (e.g. protobufs, OpenAPI, ts-rest/zod)","Document the interplay of services for other developers","This is a lot of work, and it's not even the fun part of building a product. If business requirements change and you need to change the boundaries of your services, you have to do it all over again."]},{"i":"this-leads-many-engineering-teams-to","l":"This leads many engineering teams to:","p":["Delay breaking up their monoliths when it would be beneficial to do so, or...","Break it up early and suffer the consequences of a poorly architected services architecture."]},{"l":"The Solution","p":["✅ Differential abstracts this away from you, unless you want to look under the hood. It uses HTTP.","✅ Differential comes with a dev console which gives you full observability down to the function level. You can see errors, detailed logs and execution times with zero-setup.","✅ Differential infers your service interface from your function types. Your services become end-to-end typesafe. There's no need for another interchange format.","✅ Differential provides you with the tools to keep your code co-located, but deployable as independent services at runtime.","✅ Differential services are simply javascript objects that define which functions (a.k.a business logic) belong to which service.","✅ Differential's dev console gives you a full view of your service registry, which functions are registered, and the live status for each.","✅ With Differential, you don't have to split up your codebase.","\uD83D\uDC4D This is the highest-value problem worth solving. Differential helps you focus on this problem.","Copy/Paste boilerplate code for each service and/or write libraries to abstract away the boilerplate.","Decide on a service communication protocol (HTTP, gRPC, tRPC, etc.).","Differential is an application code aware service mesh, and a distributed orchestrator. It is designed to:","Document the interplay of services for other developers.","Figure out which functionality to break out into a service.","Make it easy to break up your monolith into services","Make it easy to change the boundaries of your services as your business requirements change","Make it easy to hit \"Abort\" and go back to a monolith if you need to","Problem","Set up observability / health checks / monitoring for each service.","Solution","Split up the codebase","Write the service interfaces for each service (e.g. protobufs, OpenAPI, ts-rest/zod).","Write/move business logic for each service."]}],[{"l":"Service Discovery","p":["Status: General Availability","Differential comes with a built-in service registry, so you can call your services by name, without having to worry about IP addresses, ports, or where it's deployed. Your services phone-home to Differential control-plane.","Your services (whether running in your own compute or Differential cloud) always poll the control-plane to:","Advertise their presence","Advertise their health","Ask for work","This allows you to deploy your services anywhere, even across multiple cloud providers and regions, and still have them communicate with each other without any networking configuration.","It also cuts down the need to secure your services with service to service authentication, as the machines are not directly communicating with each other, or accepting incoming connections. This improves the security posture of your services."]}],[{"l":"Self-hosting","p":["You can self-host the Differential control-plane using your own compute, as long as you can run a Docker container. Differential only requires a postgres database for persistence."]},{"i":"guide-to-self-hosting-using-flyio","l":"Guide to self-hosting using fly.io"},{"l":"Creating the fly app","p":["Clone the repo:","Create a fly app, and note the app name:","Open the fly.toml file and replace differential-core with the app name you noted in the previous step.","Deploy to fly.io:","You will need to set a secret to access to the management functions of the control-plane. We will save the secret to a management-secret.txt file for now. You can do this by running:"]},{"l":"Creating the postgres instance","p":["Next, you will need to provision a postgres instance. You can use any postgres provider, but for this purpose, we will use fly postgres. Note the fly postgres app name when you create it.","Attach the postgres instance to the fly app. This will set the DATABASE_URL environment variable in the fly app."]},{"l":"Creating your first cluster","p":["Assuming the app is created and the postgres instance is attached, you can now create your first cluster. Assuming your app is exposed at differential-core.fly.dev, you can create a cluster by running:","Now, you can retrieve the cluster information by running:","You will only need the apiSecret from the response."]},{"l":"Connecting to the control-plane","p":["To connect to the cluster, you need:","The Typescript SDK","The endpoint where the control-plane is hosted","The apiSecret from the previous step","When initializing the SDK, you will need to pass the apiSecret and the endpoint to the Differential class.","And that's it!"]},{"l":"Additional infrastructure resources","p":["Some Differential features require additional infrastructure resources, these include:","Client library registry","Cloud deployments","In order to take advantage of these features, you will need to provision the associated resources and provide the control-plane with access."]},{"l":"Previsioning CloudFormation resources","p":["Infrastructure as code (IaC) definitions for all additional resources, as well as instructions for provisioning them reside in ./infrastructure."]},{"l":"Providing the control-plane with AWS access","p":["The stack created in the previous step, provisions an IAM User with the name DifferentialControlPlane that has IAM permissions to interact with resources hosted in AWS.","Create an Access Key using the AWS CLI's create-access-key command which can be used by the control-plane.","Create the access key for DifferentialControlPlane","Take note of the AccessKeyId and SecretAccessKey","Add the AccessKeyId and SecretAccessKey as Fly.io secrets"]},{"l":"Providing the control-plane with resource references","p":["The following environment variables will need to be made available to the control-plane:","ASSET_UPLOAD_BUCKET","DEPLOYMENT_TEMPLATE_BUCKET","DEPLOYMENT_SNS_TOPIC","Values for these can be retrieved from the previously created CloudFormation stack:","These can either be hard-coded in the control-plane's fly.toml or set as secrets using fly secrets set."]},{"l":"Upload deployment templates","p":["The control-plane retrieves template files from the DEPLOYMENT_TEMPLATE_BUCKET S3 bucket in order to create deployments.","Upload the contents of ./infrastructure/deployment-templates/ to the DEPLOYMENT_TEMPLATE_BUCKET provisioned earlier."]}],[{"l":"Typescript SDK","p":["This is the official Differential SDK for Typescript."]},{"l":"Installation"},{"l":"npm"},{"l":"yarn"},{"l":"pnpm"},{"l":"Quick Start"},{"l":"1. Initializing Differential","p":["Create a file named d.ts which will be used to initialize Differential. This file will export the Differential instance."]},{"l":"2. Hello World Service","p":["In a separate file, create the \"Hello World\" service. This file will import the Differential instance from d.ts and define the service."]},{"l":"3. Calling the Service","p":["When calling the service, use the typeof generic to ensure type safety. This can be done in any file where you need to call the service, like a test file or another service file."]},{"l":"4. Running the Service","p":["To run the service, simply run the file with the service definition. This will start the service and make it available to other services.","and then you can invoke the service from another file:"]},{"l":"Documentation","p":["Differential documentation contains all the information you need to get started with Differential."]},{"l":"Examples","p":["Monolith contains an example of a monolith application broken into multiple services.","End to end encryption contains an example of how to use Differential's end to end encryption.","Caching contains an example of how to use Differential's distributed caching."]}],[{"i":"class-differential","l":"Class: Differential","p":["The Differential client. This is the main entry point for using Differential.","Differential client exposes two main methods:","service- Registers a service with Differential. This will register all functions on the service.","client- Provides a type safe client for performing calls to a registered service.","Example"]},{"l":"Table of contents"},{"l":"Constructors","p":["constructor"]},{"l":"Methods","p":["client","service"]},{"i":"constructors-1","l":"Constructors"},{"l":"constructor","p":["• new Differential( apiSecret, options?): Differential","Initializes a new Differential instance."]},{"l":"Parameters","p":["Name","Type","Description","apiSecret","string","The API Secret for your Differential cluster. You can obtain one from https://api.differential.dev/demo/token.","options?","Object","Additional options for the Differential client.","options.encryptionKeys?","Buffer[]","An array of encryption keys to use for encrypting and decrypting data. These keys are never sent to the control-plane and allows you to encrypt function arguments and return values. If you do not provide any keys, Differential will not encrypt any data. Encryption has a performance impact on your functions. When you want to rotate keys, you can add new keys to the start of the array. Differential will try to decrypt data with each key in the array until it finds a key that works. Differential will encrypt data with the first key in the array. Each key must be 32 bytes long.","options.endpoint?","The endpoint for the Differential cluster. Defaults to https://api.differential.dev."]},{"l":"Returns","p":["Differential","Example"]},{"l":"Defined in","p":["ts-core/src/Differential.ts:410"]},{"i":"methods-1","l":"Methods"},{"l":"client","p":["▸ client< T>( service): ServiceClient< T>","Provides a type safe client for performing calls to a registered service. Waits for the function to complete before returning, and returns the result of the function call."]},{"l":"Type parameters","p":["Name","Type","T","extends RegisteredService< any>"]},{"i":"parameters-1","l":"Parameters","p":["Name","Type","service","T[definition][name]"]},{"i":"returns-1","l":"Returns","p":["ServiceClient< T>","ServiceClient","Example"]},{"i":"defined-in-1","l":"Defined in","p":["ts-core/src/Differential.ts:542","▸ client< T>( service, options): BackgroundServiceClient< T>","Provides a type safe client for performing calls to a registered service. Waits for the function to complete before returning, and returns the result of the function call."]},{"i":"type-parameters-1","l":"Type parameters","p":["Name","Type","T","extends RegisteredService< any>"]},{"i":"parameters-2","l":"Parameters","p":["Name","Type","service","T[definition][name]","options","Object","options.background","true"]},{"i":"returns-2","l":"Returns","p":["BackgroundServiceClient< T>","ServiceClient","Example"]},{"i":"defined-in-2","l":"Defined in","p":["ts-core/src/Differential.ts:546"]},{"l":"service","p":["▸ service< T, N>( service): RegisteredService< T>","Registers a service with Differential. This will register all functions on the service."]},{"i":"type-parameters-2","l":"Type parameters","p":["Name","Type","T","extends ServiceDefinition< N>","N","extends string"]},{"i":"parameters-3","l":"Parameters","p":["Name","Type","Description","service","T","The service definition."]},{"i":"returns-3","l":"Returns","p":["RegisteredService< T>","A registered service instance.","Example"]},{"i":"defined-in-3","l":"Defined in","p":["ts-core/src/Differential.ts:518"]}]]